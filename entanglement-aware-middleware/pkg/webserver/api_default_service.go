/*
 * webserver
 *
 * rest api
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package webserver

import (
	"context"
	"encoding/json"
	"errors"
	"net/http"
	"strconv"

	etcd "go.etcd.io/etcd/client/v3"
	appsv1 "k8s.io/api/apps/v1"
	v1 "k8s.io/api/core/v1"
)

// DefaultApiService is a service that implements the logic for the DefaultApiServicer
// This service should implement the business logic for every endpoint for the DefaultApi API.
// Include any external packages or services that will be required by this service.
type DefaultApiService struct {
}

// NewDefaultApiService creates a default api service
func NewDefaultApiService() DefaultApiServicer {
	return &DefaultApiService{}
}

func newEtcdClient() (*etcd.Client, error) {
	cli, err := etcd.New(etcd.Config{
		Endpoints: []string{"http://localhost:2379"},
	})
	if err != nil {
		return nil, err
	}
	return cli, nil
}

func checkKubernetesConfigs(configs []Config) error {
	for _, cfg := range configs {
		if cfg.Type == "Deployment" {
			var deployment appsv1.Deployment
			if err := json.Unmarshal([]byte(cfg.Spec), &deployment); err != nil {
				return err
			}
		} else if cfg.Type == "Service" {
			var service v1.Service
			if err := json.Unmarshal([]byte(cfg.Spec), &service); err != nil {
				return err
			}
		} else if cfg.Type == "ConfigMap" {
			var configMap v1.ConfigMap
			if err := json.Unmarshal([]byte(cfg.Spec), &configMap); err != nil {
				return err
			}
		} else {
			return errors.New("invalid config type")
		}
	}
	return nil
}

// AppsGet -
func (s *DefaultApiService) AppsGet(ctx context.Context) (ImplResponse, error) {
	cli, err := newEtcdClient()
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}
	defer cli.Close()

	resp, err := cli.Get(ctx, "/apps", etcd.WithPrefix())
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	if len(resp.Kvs) == 0 {
		return Response(http.StatusOK, []App{}), nil
	}

	var apps []App
	for _, kv := range resp.Kvs {
		var app App
		if err := json.Unmarshal(kv.Value, &app); err != nil {
			return Response(http.StatusInternalServerError, nil), err
		}
		apps = append(apps, app)
	}
	return Response(http.StatusOK, apps), nil
}

// AppsIdDelete -
func (s *DefaultApiService) AppsIdDelete(ctx context.Context, id int32) (ImplResponse, error) {
	cli, err := newEtcdClient()
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}
	defer cli.Close()

	resp, err := cli.Delete(ctx, "/apps/"+strconv.Itoa(int(id)))
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	if resp.Deleted == 0 {
		return Response(http.StatusNotFound, nil), nil
	}
	return Response(http.StatusOK, nil), nil
}

// AppsIdGet -
func (s *DefaultApiService) AppsIdGet(ctx context.Context, id int32) (ImplResponse, error) {
	cli, err := newEtcdClient()
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}
	defer cli.Close()

	resp, err := cli.Get(ctx, "/apps/"+strconv.Itoa(int(id)))
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	if len(resp.Kvs) == 0 {
		return Response(http.StatusNotFound, nil), nil
	}

	var app App
	if err := json.Unmarshal(resp.Kvs[0].Value, &app); err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}
	return Response(http.StatusOK, app), nil
}

// AppsIdPut -
func (s *DefaultApiService) AppsIdPut(ctx context.Context, id int32, app App) (ImplResponse, error) {
	cli, err := newEtcdClient()
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}
	defer cli.Close()

	resp, err := cli.Get(ctx, "/apps/"+strconv.Itoa(int(id)))
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	if len(resp.Kvs) == 0 {
		return Response(http.StatusNotFound, nil), nil
	}

	for _, dt := range app.DigitalTwins {
		for _, dep := range dt.Deployments {
			if dep.Type == "Kubernetes" {
				if err = checkKubernetesConfigs(dep.Configs); err != nil {
					return Response(http.StatusBadRequest, nil), err
				}
			} else {
				return Response(http.StatusBadRequest, nil), errors.New("invalid deployment type")
			}
		}
	}

	app.Id = id
	jsonApp, err := json.Marshal(app)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	_, err = cli.Put(ctx, "/apps/"+strconv.Itoa(int(id)), string(jsonApp))
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	return Response(http.StatusOK, nil), nil
}

// AppsPost -
func (s *DefaultApiService) AppsPost(ctx context.Context, app App) (ImplResponse, error) {
	cli, err := newEtcdClient()
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}
	defer cli.Close()

	resp, err := cli.Get(ctx, "/apps", etcd.WithPrefix())
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	var maxId int32 = 0
	for _, kv := range resp.Kvs {
		var a App
		if err := json.Unmarshal(kv.Value, &a); err != nil {
			return Response(http.StatusInternalServerError, nil), err
		}
		if a.Id > maxId {
			maxId = a.Id
		}
	}
	app.Id = maxId + 1

	for _, dt := range app.DigitalTwins {
		for _, dep := range dt.Deployments {
			if dep.Type == "Kubernetes" {
				if err = checkKubernetesConfigs(dep.Configs); err != nil {
					return Response(http.StatusBadRequest, nil), err
				}
			} else {
				return Response(http.StatusBadRequest, nil), errors.New("invalid deployment type")
			}
		}
	}

	jsonApp, err := json.Marshal(app)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	_, err = cli.Put(ctx, "/apps/"+strconv.Itoa(int(maxId+1)), string(jsonApp))
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	return Response(http.StatusCreated, app), nil
}
